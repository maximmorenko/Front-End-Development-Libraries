
// Sass, або "Syntactically Awesome StyleSheets" — це мовне розширення CSS, 
// що містить функції, яких немає у базовому CSS, і тим самим допомагає спростити 
// створення таблиць стилів для ваших проєктів.
// У цьому курсі ви навчитеся зберігати дані у змінних, вкладати CSS, 
// створювати багаторазові стилі за допомогою міксин (Mixins), додавати умовні конструкції 
// та цикли до ваших стилів тощо. 

//=========================================================================================

// Одна особливість Sass, відмінна від CSS, – це використання змінних. 
// Вони оголошуються і встановлюються для зберігання даних, як в JavaScript. 

// У JavaScript змінні визначаються за допомогою ключових слів let і const. 
// У Sass змінні починаються з $, за яким слідує ім'я змінної.

//Ось кілька прикладів:

// $main-fonts: Arial, sans-serif;
// $headings-color: green;
// Для використання змінних:

// h1 {
//   font-family: $main-fonts;
//   color: $headings-color;
// }

//==========================================================================================

// Вложенность дочерних стилей в родительский

// Sass дає змогу вкласти правила CSS, що корисно для організації таблиці стилів.
// Зазвичай кожний елемент націлений на стилізацію окремої лінії, наприклад:

// nav {
//   background-color: red;
// }

// nav ul {
//   list-style: none;
// }

// nav ul li {
//   display: inline-block;
// }
// У великому проєкті файл CSS матиме багато рядків та правил. 
// Ось де вкладання надасть змогу організувати код, помістивши дочірні 
// правила стилю до відповідних батьківських елементів:

// nav {
//   background-color: red;

//   ul {
//     list-style: none;

//     li {
//       display: inline-block;
//     }
//   }
// }

//==========================================================================================

// @mixin

// Створюйте багаторазові СSS з Mixins

// В розширенні Sass Міксини (Mixins) - це група CSS декларацій яка може бути повторно 
// використана в межах всієї таблиці стилів.

// Новіші налаштування CSS потребують трохи часу, перш ніж вони будуть повністю прийняті 
// та готові до використання у всіх браузерах. Оскільки функції додаються до браузерів, 
// правила CSS, що їх використовують, можуть потребувати вендорних (vendor) префіксів. 
// Розглянемо box-shadow:

// div {
//   -webkit-box-shadow: 0px 0px 4px #fff;
//   -moz-box-shadow: 0px 0px 4px #fff;
//   -ms-box-shadow: 0px 0px 4px #fff;
//   box-shadow: 0px 0px 4px #fff;
// }
// Потрібно вписати чимало тексту, щоб перезаписати це правило для всіх елементів, 
// які мають в собі box-shadow, чи щоб змінити кожне значення для перевірки різних ефектів. 
// Міксини - це як функції для CSS. Ось приклад як написати один з них:

// @mixin box-shadow($x, $y, $blur, $c){ 
//   -webkit-box-shadow: $x $y $blur $c;
//   -moz-box-shadow: $x $y $blur $c;
//   -ms-box-shadow: $x $y $blur $c;
//   box-shadow: $x $y $blur $c;
// }
// Визначення починається з @mixin, за яким слідує ім'я користувача. 
// Параметри ($x,$y,$blur, та $c в прикладі наведеному вище) не є обов'язковими. 
// Тепер, коли нам необхідне правило box-shadow, то лише один рядок, що викликає mixin, 
// замінює необхідність введення всіх вендорних префіксів. Міксин викликається директивою @include:

// div {
//   @include box-shadow(0px, 0px, 4px, #fff);
// }

//++++++++++++++++++++++++++++++

//Пример использования миксина

{/* <style type='text/scss'>
  @mixin border-radius($radius){
    -webkit-border-radius: $radius;
    -moz-border-radius: $radius;
    -ms-border-radius: $radius;
    border-radius: $radius;
  }

  #awesome {
    width: 150px;
    height: 150px;
    background-color: green;
    @include border-radius(15px);   
  }
</style>

<div id="awesome"></div> */}

//======================================================================================================

//  @if  @else

// Використовуйте @if і @else, щоб додати логіку у свої стилі
// Директива @if у Sass корисна для тестування конкретного випадку. 
// Вона працює, так само як оператор if у JavaScript.

// @mixin make-bold($bool) {
//     @if $bool == true {
//       font-weight: bold;
//     }
//   }
//   Як і в JavaScript, @else if і @else перевіряють наявність додаткових умов:
  
//   @mixin text-effect($val) {
//     @if $val == danger {
//       color: red;
//     }
//     @else if $val == alert {
//       color: yellow;
//     }
//     @else if $val == success {
//       color: green;
//     }
//     @else {
//       color: black;
//     }
//   }

//+++++++++++++++++++++++++++++++++++++

//<style type='text/scss'>
//@mixin border-stroke($val) {
//  @if $val == light {
//    border: 1px solid black;
//  }
//  @else if $val == medium {
//    border: 3px solid black;
//  }
//  @else if $val == heavy {
//    border: 6px solid black;
//  }
//  @else {
//    border: none;
//  }
//}
//  #box {
//    width: 150px;
//   height: 150px;
//    background-color: red;
//    @include border-stroke(medium);
//  }
//</style>

//<div id="box"></div>

//============================================================================================

//   @for

// Використовуйте @for, щоб створити цикл Sass

// Директива @for додає стилі в цикл подібно циклу for у JavaScript.

// @for використовується двома способами: «від початку до кінця» або «від початку до самого кінця». 
// Основна відмінність полягає в тому, що «від початку to до кінця» 
// виключає кінцеве число з підрахунку, 
// а «від початку до самого кінця» включає кінцеве число в підрахунок.

// Ось початок до кінцевого прикладу:

// @for $i from 1 through 12 {
//   .col-#{$i} { width: 100%/12 * $i; }
// }
// Частина #{$i} – це синтаксис, який поєднує змінну (i) з текстом для створення рядка. 
// Коли файл Sass конвертовано в CSS, це виглядає приблизно так:

// .col-1 {
//   width: 8.33333%;
// }

// .col-2 {
//   width: 16.66667%;
// }

// ...

// .col-12 {
//   width: 100%;
// }
// Це ефективний спосіб створення макету сітки. 
// Тепер у вас є дванадцять варіантів ширини стовпців, доступних як класи CSS.

//++++++++++++++++++++++++++++++++

//Напишіть директиву @for, яка приймає змінну $j від 1 до 6.

//Ця функція повинна створити 5 класів з іменами від .text-1 до .text-5, 
//де для кожного font-size встановлено значення 15 пікселів, помножене на індекс.

//<style type='text/scss'>
//@for $i from 1 through 12 {
//  .text-#{$i} {font-size: 15*$i}
//}
//</style>

//<p class="text-1">Hello</p>
//<p class="text-2">Hello</p>
//<p class="text-3">Hello</p>
//<p class="text-4">Hello</p>
//<p class="text-5">Hello</p>

//=============================================================================

//   @each

// Використовуйте @each для зіставлення елементів в списку
// Останнє завдання продемонструвало, як директива @for використовує початкове і кінцеве 
// значення для повторення циклу певну кількість разів. Sass також пропонує директиву @each, 
// яка перебирає кожен елемент в списку або на карті. На кожній ітерації змінній присвоюється 
// поточне значення зі списку або карти.

// @each $color in blue, red, green {
//   .#{$color}-text {color: $color;}
// }

// У карти трохи інший синтаксис. Ось приклад:

// $colors: (color1: blue, color2: red, color3: green);

// @each $key, $color in $colors {
//   .#{$color}-text {color: $color;}
// }

// Зверніть увагу, що змінна $key необхідна для посилання на ключі карти.
// В іншому випадку скомпільований CSS містив би color1,color2. 
// Обидва наведені вище приклади коду перетворені в наступний CSS:

// .blue-text {
//   color: blue;
// }

// .red-text {
//   color: red;
// }

// .green-text {
//   color: green;
// }

//+++++++++++++++++++++++++++++++++++++++++++++

// Напишіть директиву @each, яка проходить список: blue, black, 
// red і призначає кожній змінній клас .color-bg, де частина color змінюється для кожного елемента. 
// Кожен клас повинен встановити для background-color відповідний колір.

// <style type='text/scss'>
// @each $color in blue, black, red {
//   .#{$color}-bg {background-color: $color;}
// }

//   div {
//     height: 200px;
//     width: 200px;
//   }
// </style>

// <div class="blue-bg"></div>
// <div class="black-bg"></div>
// <div class="red-bg"></div>

//===============================================================================================

//   @while

// Директива @while - це опція з схожою функціональністю як в циклу while в Javascript. 
// Це створює правила СSS до моменту виконання умови.

// Завдання @for продемонструвало як створити просту сіткову систему. Це також може працювати з @while.

// $x: 1;
// @while $x < 13 {
//   .col-#{$x} { width: 100%/12 * $x;}
//   $x: $x + 1;
// }
// Спершу визначте змінну $x та встановіть значення 1. Далі, використовуйте 
// директиву @while для створення сіткової системи *за умови *$x - менше 13. 
// Після встановлення правила CSS для width, $x збільшується на 1, щоб уникнути нескінченного циклу.

//+++++++++++++++++++++++++++++++++++

// Використовуйте @while для створення серії класів з різними font-sizes.

// Тут повинні бути 5 різних класів від text-1 до text-5. 
// Далі встановіть font-size для 15px, помножений на поточний номер індексу. 
// Переконайтеся, що ви уникаєте безкінечного циклу!

// <style type='text/scss'>
// $x: 1;
// @while $x < 6 {
//   .text-#{$x} { font-size: 15px * $x;}
//   $x: $x + 1;
// }
// </style>

// <p class="text-1">Hello</p>
// <p class="text-2">Hello</p>
// <p class="text-3">Hello</p>
// <p class="text-4">Hello</p>
// <p class="text-5">Hello</p>

//================================================================================================

//   Partials

//Розділіть свої стилі на менші частини - партіали (Partials)

// Партіали у Sass є окремими файлами, які містять сегменти коду CSS. 
// Їх імпортують і використовують в інших файлах Sass. 
// Це відмінний спосіб групування ідентичних кодів у впорядкований модуль.

// Назви партіалів починаються з підкреслених символів (_), що повідомляють Sass про те, 
// що вони є невеликим сегментом коду CSS, який непотрібно конвертувати у файл CSS. 
// Окрім того, файли Sass закінчуються розширенням .scss. 
// Щоб перевести код у партіалі в інший файл Sass, використовуйте директиву @import.

// Наприклад, якщо всі міксини збережено в партіалі під назвою "_mixins.scss", 
// і вони також потрібні у файлі "main.scss", то їх використовують в основному файлі таким чином:

// @import 'mixins'
// Зверніть увагу, що підкреслення та розширення файлу не потрібні 
// в операторі import - Sass ідентифікує, що це партіал. 
// Як тільки партіал імпортовано у файл, усі змінні, 
// міксини та інші коди стають доступними для використання.

//========================================================================================

// Розширюйте набір СSS стилів в інший елемент

// Sass має елемент з назвою extend (розширити), який дозволяє запозичити СSS правила 
// у одного елемента та опиратися на них в іншому.

// Наприклад, наведений нижче блок СSS правил стилізує клас .panel. 
// Він включає background-color (колір фону),height (висота) та border (рамки).

// .panel{
//   background-color: red;
//   height: 70px;
//   border: 2px solid green;
// }
// Тепер вам потрібна ще інша панель з назвою.big-panel. 
// Вона має ті ж основні властивості, що і .panel, 
// але також потребує width (ширина) і font-size (розмір шрифту).
// Можливо скопіювати та вставити початкові правила CSS з .panel, але код повторюється, 
// якщо додаєте більше видів панелей. Директива extend спрощує повторне використання правил, 
// написаних для одного елемента, і додавання нових для іншого:

// .big-panel{
//   @extend .panel;
//   width: 150px;
//   font-size: 2em;
// }
// Поруч з новими стилями, клас .big-panel матиме ті ж властивості, що й клас .panel.